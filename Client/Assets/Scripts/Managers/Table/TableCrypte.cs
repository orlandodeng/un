//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Security.Cryptography;
using System.IO;

public class NetCrypte
{
	//private Aes aes = null;
	private SymmetricAlgorithm cryto = null;
	private byte[] iv;
	private byte[] key;
	public bool isCrypte = true;
	public int pkgLen = 2;
	public int blockSize = 128;

	public NetCrypte ()
	{
		//if (aes == null)
		//	return;
		//aes = AesManaged.Create ();
		//aes = AesCryptoServiceProvider.Create ();

		//InitDes ();
		InitAes ();
		setIV ("d62f5b5677d299957ab8aa8fe7dd95e7");
		setKey("d62f5b5677d299957ab8aa8fe7dd95e7");
	}

	public void InitAes()
	{
		cryto = new RijndaelManaged ();
		cryto.Padding = PaddingMode.Zeros;
		cryto.BlockSize = 128;
		cryto.Mode = CipherMode.CBC;
		blockSize = 128;
	}

	public void InitDes()
	{
		cryto = new DESCryptoServiceProvider ();
		cryto.Padding = PaddingMode.Zeros;
		cryto.BlockSize = 64;
		cryto.Mode = CipherMode.CBC;
		blockSize = 64;
	}

	public static byte[] ParseHexString(string hexString)
	{
		byte[] outData = new byte[(int)Math.Ceiling(((double)hexString.Length) / 2)];
		for(int i=0; i<outData.Length; ++i)
		{
			string s = hexString.Substring(i*2, 2);
			outData[i] = byte.Parse(s, System.Globalization.NumberStyles.AllowHexSpecifier);
		}
		return outData;
	}

	public void setIV(string hexString) 
	{
		if (cryto == null)
			return;
		iv = ParseHexString (hexString.Substring(0, blockSize/4));
		cryto.IV = iv;
	}
	public void setKey(string hexString)
	{
		if (cryto == null)
			return;
		key = ParseHexString (hexString.Substring(0, blockSize/4));
		cryto.Key = key;
	}

	public byte[] Encrypte(byte[] inData)
	{
		if (!isCrypte)
		//if (true)
			return inData;
		System.Security.Cryptography.ICryptoTransform trs = cryto.CreateEncryptor ();
		byte[] eData = trs.TransformFinalBlock (inData, 0, inData.Length);
		byte[] outData = new byte[eData.Length + pkgLen];

		switch (pkgLen) {
		case 2:
			BitConverter.GetBytes (System.Net.IPAddress.HostToNetworkOrder ((short)inData.Length)).CopyTo (outData, 0);
			break;
		case 4:
			BitConverter.GetBytes(System.Net.IPAddress.HostToNetworkOrder((int)inData.Length)).CopyTo (outData, 0);
			break;
		}
		eData.CopyTo (outData, pkgLen);
		return outData;
	}

	public byte[] Decrypte (byte[] inData)
	{
		if (!isCrypte)
		//if (true)
			return inData;
		UInt32 len = 0;
		switch (pkgLen) {
		case 2:
			if (inData.Length < 2) {
				UnityEngine.Debug.LogError("indata len less then 2." + inData.Length);
			}
			len = (UInt32)((UInt16)System.Net.IPAddress.NetworkToHostOrder ((short)BitConverter.ToUInt16 (inData, 0)));
			break;
		case 4:
			len = (UInt32)System.Net.IPAddress.NetworkToHostOrder ((int)BitConverter.ToUInt32 (inData, 0));
			break;
		}
		System.Security.Cryptography.ICryptoTransform trs = cryto.CreateDecryptor (key, iv);
		byte[] outData = new byte[len];
		byte[] ddate = trs.TransformFinalBlock (inData, pkgLen, inData.Length - pkgLen);
		Array.Copy (ddate, outData, len);
		//UnityEngine.Debug.Log("decrypte inData:" + BitConverter.ToString(inData));
		//UnityEngine.Debug.Log("decrypte outData:" + BitConverter.ToString(outData));
		return outData;
	}
}


